Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var trace_1 = require("@nativescript/core/trace");
exports.CATEGORY = "detached-loader";
function log(message) {
    trace_1.write(message, exports.CATEGORY);
}
/**
 * Wrapper component used for loading components when navigating
 * It uses DetachedContainer as selector so that it is containerRef is not attached to
 * the visual tree.
 */
var ɵngcc0 = require('@angular/core');
var DetachedLoader = /** @class */ (function () {
    function DetachedLoader(resolver, changeDetector, containerRef) {
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.containerRef = containerRef;
    }
    DetachedLoader.prototype.loadInLocation = function (componentType) {
        var factory = this.resolver.resolveComponentFactory(componentType);
        var componentRef = this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector);
        // Component is created, built may not be checked if we are loading
        // inside component with OnPush CD strategy. Mark us for check to be sure CD will reach us.
        // We are inside a promise here so no need for setTimeout - CD should trigger
        // after the promise.
        log("DetachedLoader.loadInLocation component loaded -> markForCheck");
        return Promise.resolve(componentRef);
    };
    DetachedLoader.prototype.detectChanges = function () {
        this.changeDetector.markForCheck();
    };
    // TODO: change this API -- async promises not needed here anymore.
    DetachedLoader.prototype.loadComponent = function (componentType) {
        log("DetachedLoader.loadComponent");
        return this.loadInLocation(componentType);
    };
    DetachedLoader.prototype.loadWithFactory = function (factory) {
        return this.containerRef.createComponent(factory, this.containerRef.length, this.containerRef.injector, null);
    };
    DetachedLoader = __decorate([ __metadata("design:paramtypes", [core_1.ComponentFactoryResolver,
            core_1.ChangeDetectorRef,
            core_1.ViewContainerRef])
    ], DetachedLoader);
DetachedLoader.ɵfac = function DetachedLoader_Factory(t) { return new (t || DetachedLoader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
DetachedLoader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DetachedLoader, selectors: [["DetachedContainer"]], decls: 2, vars: 0, consts: [["loader", ""]], template: function DetachedLoader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "Placeholder", null, 0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DetachedLoader, [{
        type: core_1.Component,
        args: [{
                selector: "DetachedContainer",
                template: "<Placeholder #loader></Placeholder>"
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ViewContainerRef }]; }, null); })();
    return DetachedLoader;
}());
exports.DetachedLoader = DetachedLoader;

//# sourceMappingURL=detached-loader.js.map