{"version":3,"file":"page-router-outlet.js","sources":["page-router-outlet.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAyB;AACzB;AACA;AACA;AACA","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar router_1 = require(\"@angular/router\");\nvar frame_1 = require(\"@nativescript/core/ui/frame\");\nvar page_1 = require(\"@nativescript/core/ui/page\");\nvar profiling_1 = require(\"@nativescript/core/profiling\");\nvar rxjs_1 = require(\"rxjs\");\nvar platform_providers_1 = require(\"../platform-providers\");\nvar trace_1 = require(\"../trace\");\nvar detached_loader_1 = require(\"../common/detached-loader\");\nvar view_util_1 = require(\"../view-util\");\nvar ns_location_strategy_1 = require(\"./ns-location-strategy\");\nvar ns_route_reuse_strategy_1 = require(\"./ns-route-reuse-strategy\");\nvar PageRoute = /** @class */ (function () {\n    function PageRoute(startRoute) {\n        this.activatedRoute = new rxjs_1.BehaviorSubject(startRoute);\n    }\n    return PageRoute;\n}());\nexports.PageRoute = PageRoute;\n// Used to \"mark\" ActivatedRoute snapshots that are handled in PageRouterOutlet\nexports.pageRouterActivatedSymbol = Symbol(\"page-router-activated\");\nexports.loaderRefSymbol = Symbol(\"loader-ref\");\nfunction destroyComponentRef(componentRef) {\n    if (componentRef) {\n        var loaderRef = componentRef[exports.loaderRefSymbol];\n        if (loaderRef) {\n            loaderRef.destroy();\n        }\n        componentRef.destroy();\n    }\n}\nexports.destroyComponentRef = destroyComponentRef;\nvar DestructibleInjector = /** @class */ (function () {\n    function DestructibleInjector(destructableProviders, parent) {\n        this.destructableProviders = destructableProviders;\n        this.parent = parent;\n        this.refs = new Set();\n    }\n    DestructibleInjector.prototype.get = function (token, notFoundValue, flags) {\n        var ref = this.parent.get(token, notFoundValue, flags);\n        if (this.destructableProviders.has(token)) {\n            this.refs.add(ref);\n        }\n        return ref;\n    };\n    DestructibleInjector.prototype.destroy = function () {\n        this.refs.forEach(function (ref) {\n            if (ref.ngOnDestroy instanceof Function) {\n                ref.ngOnDestroy();\n            }\n        });\n        this.refs.clear();\n    };\n    return DestructibleInjector;\n}());\n/**\n * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.\n * We can gat additional ActivatedRoutes nodes when there is:\n *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup\n *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig\n *\n * Example:\n *   R  <-- root\n *   |\n * feature (lazy module) <-- RouteConfig: { path: \"lazy\", loadChildren: \"./feature/feature.module#FeatureModule\" }\n *   |\n * module (componentless route) <-- RouteConfig: { path: \"module\", children: [...] } // Note: No 'component'\n *   |\n *  home <-- RouteConfig: { path: \"module\", component: MyComponent } - this is what we get as activatedRoute param\n *\n *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and\n *  use this ActivateRoute as a kay for caching.\n */\nfunction findTopActivatedRouteNodeForOutlet(activatedRoute) {\n    var outletActivatedRoute = activatedRoute;\n    while (outletActivatedRoute.parent &&\n        outletActivatedRoute.parent.routeConfig &&\n        !outletActivatedRoute.parent.routeConfig.component) {\n        outletActivatedRoute = outletActivatedRoute.parent;\n    }\n    return outletActivatedRoute;\n}\nexports.findTopActivatedRouteNodeForOutlet = findTopActivatedRouteNodeForOutlet;\nfunction routeToString(activatedRoute) {\n    return activatedRoute.pathFromRoot.join(\"->\");\n}\nvar PageRouterOutlet = /** @class */ (function () {\n    function PageRouterOutlet(parentContexts, location, name, actionBarVisibility, isEmptyOutlet, locationStrategy, componentFactoryResolver, resolver, changeDetector, device, pageFactory, routeReuseStrategy, elRef) {\n        this.parentContexts = parentContexts;\n        this.location = location;\n        this.locationStrategy = locationStrategy;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.resolver = resolver;\n        this.changeDetector = changeDetector;\n        this.pageFactory = pageFactory;\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.activateEvents = new core_1.EventEmitter(); // tslint:disable-line:no-output-rename\n        this.deactivateEvents = new core_1.EventEmitter(); // tslint:disable-line:no-output-rename\n        this.isEmptyOutlet = isEmptyOutlet;\n        this.frame = elRef.nativeElement;\n        this.setActionBarVisibility(actionBarVisibility);\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.constructor frame: \" + this.frame);\n        }\n        this.name = name || router_1.PRIMARY_OUTLET;\n        parentContexts.onChildOutletCreated(this.name, this);\n        this.viewUtil = new view_util_1.ViewUtil(device);\n        this.detachedLoaderFactory = resolver.resolveComponentFactory(detached_loader_1.DetachedLoader);\n    }\n    Object.defineProperty(PageRouterOutlet.prototype, \"locationInjector\", {\n        /** @deprecated from Angular since v4 */\n        get: function () { return this.location.injector; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageRouterOutlet.prototype, \"locationFactoryResolver\", {\n        /** @deprecated from Angular since v4 */\n        get: function () { return this.resolver; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageRouterOutlet.prototype, \"isActivated\", {\n        get: function () {\n            return !!this.activated;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageRouterOutlet.prototype, \"component\", {\n        get: function () {\n            if (!this.activated) {\n                if (trace_1.isLogEnabled()) {\n                    trace_1.routerLog(\"Outlet is not activated\");\n                }\n                return;\n            }\n            return this.activated.instance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageRouterOutlet.prototype, \"activatedRoute\", {\n        get: function () {\n            if (!this.activated) {\n                if (trace_1.isLogEnabled()) {\n                    trace_1.routerLog(\"Outlet is not activated\");\n                }\n                return;\n            }\n            return this._activatedRoute;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PageRouterOutlet.prototype.setActionBarVisibility = function (actionBarVisibility) {\n        switch (actionBarVisibility) {\n            case \"always\":\n            case \"never\":\n                this.frame.actionBarVisibility = actionBarVisibility;\n                return;\n            default:\n                this.frame.actionBarVisibility = \"auto\";\n        }\n    };\n    PageRouterOutlet.prototype.ngOnDestroy = function () {\n        var _this = this;\n        // Clear accumulated modal view page cache when page-router-outlet\n        // destroyed on modal view closing\n        this.parentContexts.onChildOutletDestroyed(this.name);\n        if (this.outlet) {\n            this.outlet.outletKeys.forEach(function (key) {\n                _this.routeReuseStrategy.clearModalCache(key);\n            });\n            this.locationStrategy.clearOutlet(this.frame);\n        }\n        else {\n            trace_1.routerLog(\"PageRouterOutlet.ngOnDestroy: no outlet available for page-router-outlet\");\n        }\n        if (this.isActivated) {\n            var c = this.activated.instance;\n            this.activated.hostView.detach();\n            destroyComponentRef(this.activated);\n            this.deactivateEvents.emit(c);\n            this.activated = null;\n        }\n    };\n    PageRouterOutlet.prototype.deactivate = function () {\n        if (!this.outlet || !this.outlet.isPageNavigationBack) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"Currently not in page back navigation - component should be detached instead of deactivated.\");\n            }\n            return;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.deactivate() while going back - should destroy\");\n        }\n        if (!this.isActivated) {\n            return;\n        }\n        var c = this.activated.instance;\n        destroyComponentRef(this.activated);\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    PageRouterOutlet.prototype.detach = function () {\n        if (!this.isActivated) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"Outlet is not activated\");\n            }\n            return;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.detach() - \" + routeToString(this._activatedRoute));\n        }\n        // Detach from ChangeDetection\n        this.activated.hostView.detach();\n        var component = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        return component;\n    };\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    PageRouterOutlet.prototype.attach = function (ref, activatedRoute) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.attach() - \" + routeToString(activatedRoute));\n        }\n        this.activated = ref;\n        // reattach to ChangeDetection\n        this.activated.hostView.markForCheck();\n        this.activated.hostView.reattach();\n        this._activatedRoute = activatedRoute;\n        this.markActivatedRoute(activatedRoute);\n        this.locationStrategy._finishBackPageNavigation(this.frame);\n    };\n    /**\n     * Called by the Router to instantiate a new component during the commit phase of a navigation.\n     * This method in turn is responsible for calling the `routerOnActivate` hook of its child.\n     */\n    PageRouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {\n        this.outlet = this.outlet || this.getOutlet(activatedRoute.snapshot);\n        if (!this.outlet) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerError(\"No outlet found relative to activated route\");\n            }\n            return;\n        }\n        this.outlet.isNSEmptyOutlet = this.isEmptyOutlet;\n        this.locationStrategy.updateOutletFrame(this.outlet, this.frame, this.isEmptyOutlet);\n        if (this.outlet && this.outlet.isPageNavigationBack) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"Currently in page back navigation - component should be reattached instead of activated.\");\n            }\n            this.locationStrategy._finishBackPageNavigation(this.frame);\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.activateWith() - \" + routeToString(activatedRoute));\n        }\n        this._activatedRoute = activatedRoute;\n        this.markActivatedRoute(activatedRoute);\n        resolver = resolver || this.resolver;\n        this.activateOnGoForward(activatedRoute, resolver);\n        this.activateEvents.emit(this.activated.instance);\n    };\n    PageRouterOutlet.prototype.activateOnGoForward = function (activatedRoute, loadedResolver) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"PageRouterOutlet.activate() forward navigation - \" +\n                \"create detached loader in the loader container\");\n        }\n        var factory = this.getComponentFactory(activatedRoute, loadedResolver);\n        var page = this.pageFactory({\n            isNavigation: true,\n            componentType: factory.componentType,\n        });\n        var destructables = new Set([platform_providers_1.PageService]);\n        var injector = core_1.Injector.create({\n            providers: [\n                { provide: page_1.Page, useValue: page },\n                { provide: platform_providers_1.PageService, useClass: platform_providers_1.PageService, deps: [page_1.Page] },\n                { provide: frame_1.Frame, useValue: this.frame },\n                { provide: PageRoute, useValue: new PageRoute(activatedRoute) },\n                { provide: router_1.ActivatedRoute, useValue: activatedRoute },\n                { provide: router_1.ChildrenOutletContexts,\n                    useValue: this.parentContexts.getOrCreateContext(this.name).children }\n            ],\n            parent: this.location.injector\n        });\n        var childInjector = new DestructibleInjector(destructables, injector);\n        var loaderRef = this.location.createComponent(this.detachedLoaderFactory, this.location.length, childInjector, []);\n        loaderRef.onDestroy(function () { return childInjector.destroy(); });\n        this.changeDetector.markForCheck();\n        this.activated = loaderRef.instance.loadWithFactory(factory);\n        this.loadComponentInPage(page, this.activated, { activatedRoute: activatedRoute });\n        this.activated[exports.loaderRefSymbol] = loaderRef;\n    };\n    PageRouterOutlet.prototype.loadComponentInPage = function (page, componentRef, navigationContext) {\n        var _this = this;\n        // Component loaded. Find its root native view.\n        var componentView = componentRef.location.nativeElement;\n        // Remove it from original native parent.\n        this.viewUtil.removeChild(componentView.parent, componentView);\n        // Add it to the new page\n        this.viewUtil.insertChild(page, componentView);\n        var navigatedFromCallback = global.Zone.current.wrap(function (args) {\n            if (args.isBackNavigation) {\n                _this.locationStrategy._beginBackPageNavigation(_this.frame);\n                _this.locationStrategy.back(null, _this.frame);\n            }\n        });\n        page.on(page_1.Page.navigatedFromEvent, navigatedFromCallback);\n        componentRef.onDestroy(function () {\n            if (page) {\n                page.off(page_1.Page.navigatedFromEvent, navigatedFromCallback);\n                page = null;\n            }\n        });\n        var navOptions = this.locationStrategy._beginPageNavigation(this.frame);\n        // Clear refCache if navigation with clearHistory\n        if (navOptions.clearHistory) {\n            var clearCallback = function () { return setTimeout(function () {\n                if (_this.outlet) {\n                    _this.routeReuseStrategy.clearCache(_this.outlet.outletKeys[0]);\n                }\n            }); };\n            page.once(page_1.Page.navigatedToEvent, clearCallback);\n        }\n        this.frame.navigate({\n            create: function () {\n                return page;\n            },\n            context: navigationContext,\n            clearHistory: navOptions.clearHistory,\n            animated: navOptions.animated,\n            transition: navOptions.transition\n        });\n    };\n    // Find and mark the top activated route as an activated one.\n    // In ns-location-strategy we are reusing components only if their corresponing routes\n    // are marked as activated from this method.\n    PageRouterOutlet.prototype.markActivatedRoute = function (activatedRoute) {\n        var queue = [];\n        queue.push(activatedRoute.snapshot);\n        var currentRoute = queue.shift();\n        while (currentRoute) {\n            currentRoute.children.forEach(function (childRoute) {\n                queue.push(childRoute);\n            });\n            var topActivatedRoute = findTopActivatedRouteNodeForOutlet(currentRoute);\n            var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);\n            var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);\n            if (outlet && outlet.frames.length) {\n                topActivatedRoute[exports.pageRouterActivatedSymbol] = true;\n                if (trace_1.isLogEnabled()) {\n                    trace_1.routerLog(\"Activated route marked as page: \" + routeToString(topActivatedRoute));\n                }\n            }\n            currentRoute = queue.shift();\n        }\n    };\n    PageRouterOutlet.prototype.getComponentFactory = function (activatedRoute, loadedResolver) {\n        var component = activatedRoute.routeConfig.component;\n        return loadedResolver ?\n            loadedResolver.resolveComponentFactory(component) :\n            this.componentFactoryResolver.resolveComponentFactory(component);\n    };\n    PageRouterOutlet.prototype.getOutlet = function (activatedRouteSnapshot) {\n        var topActivatedRoute = findTopActivatedRouteNodeForOutlet(activatedRouteSnapshot);\n        var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);\n        var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);\n        // Named lazy loaded outlet.\n        if (!outlet && this.isEmptyOutlet) {\n            var parentOutletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute.parent);\n            outlet = this.locationStrategy.findOutlet(parentOutletKey, topActivatedRoute.parent);\n            if (outlet) {\n                outlet.outletKeys.push(outletKey);\n            }\n        }\n        return outlet;\n    };\n    __decorate([\n        core_1.Output(\"activate\"),\n        __metadata(\"design:type\", Object)\n    ], PageRouterOutlet.prototype, \"activateEvents\", void 0);\n    __decorate([\n        core_1.Output(\"deactivate\"),\n        __metadata(\"design:type\", Object)\n    ], PageRouterOutlet.prototype, \"deactivateEvents\", void 0);\n    __decorate([\n        profiling_1.profile,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [router_1.ActivatedRoute,\n            core_1.ComponentFactoryResolver]),\n        __metadata(\"design:returntype\", void 0)\n    ], PageRouterOutlet.prototype, \"activateWith\", null);\n    __decorate([\n        profiling_1.profile,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [page_1.Page, core_1.ComponentRef, Object]),\n        __metadata(\"design:returntype\", void 0)\n    ], PageRouterOutlet.prototype, \"loadComponentInPage\", null);\n    PageRouterOutlet = __decorate([\n        core_1.Directive({ selector: \"page-router-outlet\" }) // tslint:disable-line:directive-selector\n        ,\n        __param(2, core_1.Attribute(\"name\")),\n        __param(3, core_1.Attribute(\"actionBarVisibility\")),\n        __param(4, core_1.Attribute(\"isEmptyOutlet\")),\n        __param(9, core_1.Inject(platform_providers_1.DEVICE)),\n        __param(10, core_1.Inject(platform_providers_1.PAGE_FACTORY)),\n        __metadata(\"design:paramtypes\", [router_1.ChildrenOutletContexts,\n            core_1.ViewContainerRef, String, String, Boolean, ns_location_strategy_1.NSLocationStrategy,\n            core_1.ComponentFactoryResolver,\n            core_1.ComponentFactoryResolver,\n            core_1.ChangeDetectorRef, Object, Function, ns_route_reuse_strategy_1.NSRouteReuseStrategy,\n            core_1.ElementRef])\n    ], PageRouterOutlet);\n    return PageRouterOutlet;\n}());\nexports.PageRouterOutlet = PageRouterOutlet;\n"]}