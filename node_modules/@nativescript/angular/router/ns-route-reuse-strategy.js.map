{"version":3,"file":"ns-route-reuse-strategy.js","sources":["ns-route-reuse-strategy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAEO;AACP;;;;;mGAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar trace_1 = require(\"../trace\");\nvar ns_location_strategy_1 = require(\"./ns-location-strategy\");\nvar page_router_outlet_1 = require(\"./page-router-outlet\");\n/**\n * Detached state cache\n */\nvar DetachedStateCache = /** @class */ (function () {\n    function DetachedStateCache() {\n        this.cache = new Array();\n    }\n    Object.defineProperty(DetachedStateCache.prototype, \"length\", {\n        get: function () {\n            return this.cache.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DetachedStateCache.prototype.push = function (cacheItem) {\n        this.cache.push(cacheItem);\n    };\n    DetachedStateCache.prototype.pop = function () {\n        return this.cache.pop();\n    };\n    DetachedStateCache.prototype.peek = function () {\n        return this.cache[this.cache.length - 1];\n    };\n    DetachedStateCache.prototype.clear = function () {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"DetachedStateCache.clear() \" + this.cache.length + \" items will be destroyed\");\n        }\n        while (this.cache.length > 0) {\n            var state = this.cache.pop().state;\n            if (!state.componentRef) {\n                throw new Error(\"No componentRed found in DetachedRouteHandle\");\n            }\n            page_router_outlet_1.destroyComponentRef(state.componentRef);\n        }\n    };\n    DetachedStateCache.prototype.clearModalCache = function () {\n        var removedItemsCount = 0;\n        var hasModalPages = this.cache.some(function (cacheItem) {\n            return cacheItem.isModal;\n        });\n        if (hasModalPages) {\n            var modalCacheCleared = false;\n            while (!modalCacheCleared) {\n                var cacheItem = this.peek();\n                var state = cacheItem.state;\n                if (!state.componentRef) {\n                    throw new Error(\"No componentRef found in DetachedRouteHandle\");\n                }\n                page_router_outlet_1.destroyComponentRef(state.componentRef);\n                if (cacheItem.isModal) {\n                    modalCacheCleared = true;\n                }\n                this.pop();\n                removedItemsCount++;\n            }\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"DetachedStateCache.clearModalCache() \" + removedItemsCount + \" items will be destroyed\");\n        }\n    };\n    return DetachedStateCache;\n}());\n/**\n * Detaches subtrees loaded inside PageRouterOutlet in forward navigation\n * and reattaches them on back.\n * Reuses routes as long as their route config is the same.\n */\nvar NSRouteReuseStrategy = /** @class */ (function () {\n    function NSRouteReuseStrategy(location) {\n        this.location = location;\n        this.cacheByOutlet = {};\n    }\n    NSRouteReuseStrategy.prototype.shouldDetach = function (route) {\n        route = page_router_outlet_1.findTopActivatedRouteNodeForOutlet(route);\n        var outletKey = this.location.getRouteFullPath(route);\n        var outlet = this.location.findOutlet(outletKey, route);\n        var key = getSnapshotKey(route);\n        var isPageActivated = route[page_router_outlet_1.pageRouterActivatedSymbol];\n        var isBack = outlet ? outlet.isPageNavigationBack : false;\n        var shouldDetach = outlet && !isBack && isPageActivated;\n        if (outlet) {\n            if (outlet.parent && !outlet.parent.shouldDetach) {\n                shouldDetach = false;\n            }\n            outlet.shouldDetach = shouldDetach;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"shouldDetach isBack: \" + isBack + \" key: \" + key + \" result: \" + shouldDetach);\n        }\n        return shouldDetach;\n    };\n    NSRouteReuseStrategy.prototype.shouldAttach = function (route) {\n        route = page_router_outlet_1.findTopActivatedRouteNodeForOutlet(route);\n        var outletKey = this.location.getRouteFullPath(route);\n        var outlet = this.location.findOutlet(outletKey, route);\n        var cache = this.cacheByOutlet[outletKey];\n        if (!cache) {\n            return false;\n        }\n        var key = getSnapshotKey(route);\n        var isBack = outlet ? outlet.isPageNavigationBack : false;\n        var shouldAttach = isBack && cache.peek().key === key;\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"shouldAttach isBack: \" + isBack + \" key: \" + key + \" result: \" + shouldAttach);\n        }\n        if (outlet) {\n            outlet.shouldDetach = true;\n        }\n        return shouldAttach;\n    };\n    NSRouteReuseStrategy.prototype.store = function (route, state) {\n        route = page_router_outlet_1.findTopActivatedRouteNodeForOutlet(route);\n        var key = getSnapshotKey(route);\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"store key: \" + key + \", state: \" + state);\n        }\n        var outletKey = this.location.getRouteFullPath(route);\n        // tslint:disable-next-line:max-line-length\n        var cache = this.cacheByOutlet[outletKey] = this.cacheByOutlet[outletKey] || new DetachedStateCache();\n        if (state) {\n            var isModal = false;\n            if (this.location._modalNavigationDepth > 0) {\n                isModal = true;\n            }\n            cache.push({ key: key, state: state, isModal: isModal });\n        }\n        else {\n            var topItem = cache.peek();\n            if (topItem.key === key) {\n                cache.pop();\n                if (!cache.length) {\n                    delete this.cacheByOutlet[outletKey];\n                }\n            }\n            else {\n                throw new Error(\"Trying to pop from DetachedStateCache but keys don't match. \" +\n                    (\"expected: \" + topItem.key + \" actual: \" + key));\n            }\n        }\n    };\n    NSRouteReuseStrategy.prototype.retrieve = function (route) {\n        route = page_router_outlet_1.findTopActivatedRouteNodeForOutlet(route);\n        var outletKey = this.location.getRouteFullPath(route);\n        var outlet = this.location.findOutlet(outletKey, route);\n        var cache = this.cacheByOutlet[outletKey];\n        if (!cache) {\n            return null;\n        }\n        var key = getSnapshotKey(route);\n        var isBack = outlet ? outlet.isPageNavigationBack : false;\n        var cachedItem = cache.peek();\n        var state = null;\n        if (isBack && cachedItem && cachedItem.key === key) {\n            state = cachedItem.state;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"retrieved isBack: \" + isBack + \" key: \" + key + \" state: \" + state);\n        }\n        return state;\n    };\n    NSRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {\n        var shouldReuse = future.routeConfig === curr.routeConfig;\n        if (shouldReuse && curr && curr[page_router_outlet_1.pageRouterActivatedSymbol]) {\n            // When reusing route - copy the pageRouterActivated to the new snapshot\n            // It's needed in shouldDetach to determine if the route should be detached.\n            future[page_router_outlet_1.pageRouterActivatedSymbol] = curr[page_router_outlet_1.pageRouterActivatedSymbol];\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routeReuseStrategyLog(\"shouldReuseRoute result: \" + shouldReuse);\n        }\n        return shouldReuse;\n    };\n    NSRouteReuseStrategy.prototype.clearCache = function (outletKey) {\n        var cache = this.cacheByOutlet[outletKey];\n        if (cache) {\n            cache.clear();\n        }\n    };\n    NSRouteReuseStrategy.prototype.clearModalCache = function (outletKey) {\n        var cache = this.cacheByOutlet[outletKey];\n        if (cache) {\n            cache.clearModalCache();\n        }\n    };\n    NSRouteReuseStrategy = __decorate([\n        core_1.Injectable(),\n        __metadata(\"design:paramtypes\", [ns_location_strategy_1.NSLocationStrategy])\n    ], NSRouteReuseStrategy);\n    return NSRouteReuseStrategy;\n}());\nexports.NSRouteReuseStrategy = NSRouteReuseStrategy;\nfunction getSnapshotKey(snapshot) {\n    return snapshot.pathFromRoot.join(\"->\");\n}\n"]}