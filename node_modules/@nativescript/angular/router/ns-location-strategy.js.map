{"version":3,"file":"ns-location-strategy.js","sources":["ns-location-strategy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAEO;AACP;;;;;2FAA2B;AAC3B;AACA;AACA;AACA","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar common_1 = require(\"@angular/common\");\nvar router_1 = require(\"@angular/router\");\nvar trace_1 = require(\"../trace\");\nvar lang_facade_1 = require(\"../lang-facade\");\nvar platform_providers_1 = require(\"../platform-providers\");\nvar Outlet = /** @class */ (function () {\n    function Outlet(outletKey, path, pathByOutlets, modalNavigationDepth) {\n        // More than one frame available when using NSEmptyOutletComponent component\n        // in module that lazy loads children (loadChildren) and has outlet name.\n        this.frames = [];\n        this.states = [];\n        // Used in reuse-strategy by its children to determine if they should be detached too.\n        this.shouldDetach = true;\n        this.outletKeys = [outletKey];\n        this.isPageNavigationBack = false;\n        this.showingModal = false;\n        this.modalNavigationDepth = modalNavigationDepth || 0;\n        this.pathByOutlets = pathByOutlets;\n        this.path = path;\n    }\n    Outlet.prototype.containsFrame = function (frame) {\n        return this.frames.indexOf(frame) > -1;\n    };\n    Outlet.prototype.peekState = function () {\n        if (this.states.length > 0) {\n            return this.states[this.states.length - 1];\n        }\n        return null;\n    };\n    Outlet.prototype.containsTopState = function (stateUrl) {\n        var lastState = this.peekState();\n        return lastState && lastState.segmentGroup.toString() === stateUrl;\n    };\n    // Search for frame that can go back.\n    // Nested 'primary' outlets could result in Outlet with multiple navigatable frames.\n    Outlet.prototype.getFrameToBack = function () {\n        var frame = this.frames[this.frames.length - 1];\n        if (!this.isNSEmptyOutlet) {\n            for (var index = this.frames.length - 1; index >= 0; index--) {\n                var currentFrame = this.frames[index];\n                if (currentFrame.canGoBack()) {\n                    frame = currentFrame;\n                    break;\n                }\n            }\n        }\n        return frame;\n    };\n    return Outlet;\n}());\nexports.Outlet = Outlet;\nvar defaultNavOptions = {\n    clearHistory: false,\n    animated: true\n};\nvar NSLocationStrategy = /** @class */ (function (_super) {\n    __extends(NSLocationStrategy, _super);\n    function NSLocationStrategy(frameService) {\n        var _this = _super.call(this) || this;\n        _this.frameService = frameService;\n        _this.outlets = [];\n        _this.popStateCallbacks = new Array();\n        _this._modalNavigationDepth = 0;\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.constructor()\");\n        }\n        return _this;\n    }\n    NSLocationStrategy.prototype.path = function () {\n        if (!this.currentUrlTree) {\n            return \"/\";\n        }\n        var state = this.currentOutlet && this.currentOutlet.peekState();\n        if (!state) {\n            return \"/\";\n        }\n        var tree = this.currentUrlTree;\n        var changedOutlet = this.getSegmentGroupByOutlet(this.currentOutlet);\n        // Handle case where the user declares a component at path \"/\".\n        // The url serializer doesn't parse this url as having a primary outlet.\n        if (state.isRootSegmentGroup) {\n            tree.root = state.segmentGroup;\n        }\n        else if (changedOutlet) {\n            this.updateSegmentGroup(tree.root, changedOutlet, state.segmentGroup);\n        }\n        var urlSerializer = new router_1.DefaultUrlSerializer();\n        var url = urlSerializer.serialize(tree);\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.path(): \" + url);\n        }\n        return url;\n    };\n    NSLocationStrategy.prototype.prepareExternalUrl = function (internal) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.prepareExternalUrl() internal: \" + internal);\n        }\n        return internal;\n    };\n    NSLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.pushState state: \" +\n                (state + \", title: \" + title + \", url: \" + url + \", queryParams: \" + queryParams));\n        }\n        this.pushStateInternal(state, title, url, queryParams);\n    };\n    NSLocationStrategy.prototype.pushStateInternal = function (state, title, url, queryParams) {\n        var _this = this;\n        var urlSerializer = new router_1.DefaultUrlSerializer();\n        this.currentUrlTree = urlSerializer.parse(url);\n        var urlTreeRoot = this.currentUrlTree.root;\n        // Handle case where the user declares a component at path \"/\".\n        // The url serializer doesn't parse this url as having a primary outlet.\n        if (!Object.keys(urlTreeRoot.children).length) {\n            var segmentGroup = this.currentUrlTree && this.currentUrlTree.root;\n            var outletKey = this.getOutletKey(this.getSegmentGroupFullPath(segmentGroup), \"primary\");\n            var outlet = this.findOutlet(outletKey);\n            if (outlet && this.updateStates(outlet, segmentGroup)) {\n                this.currentOutlet = outlet; // If states updated\n            }\n            else if (!outlet) {\n                var rootOutlet = this.createOutlet(\"primary\", null, segmentGroup, null);\n                this.currentOutlet = rootOutlet;\n            }\n            this.currentOutlet.peekState().isRootSegmentGroup = true;\n            return;\n        }\n        var queue = [];\n        var currentTree = urlTreeRoot;\n        while (currentTree) {\n            Object.keys(currentTree.children).forEach(function (outletName) {\n                var currentSegmentGroup = currentTree.children[outletName];\n                currentSegmentGroup.outlet = outletName;\n                currentSegmentGroup.root = urlTreeRoot;\n                var outletPath = _this.getSegmentGroupFullPath(currentTree);\n                var outletKey = _this.getOutletKey(outletPath, outletName);\n                var outlet = _this.findOutlet(outletKey);\n                var parentOutletName = currentTree.outlet || \"\";\n                var parentOutletPath = _this.getSegmentGroupFullPath(currentTree.parent);\n                var parentOutletKey = _this.getOutletKey(parentOutletPath, parentOutletName);\n                var parentOutlet = _this.findOutlet(parentOutletKey);\n                var containsLastState = outlet && outlet.containsTopState(currentSegmentGroup.toString());\n                if (!outlet) {\n                    // tslint:disable-next-line:max-line-length\n                    outlet = _this.createOutlet(outletKey, outletPath, currentSegmentGroup, parentOutlet, _this._modalNavigationDepth);\n                    _this.currentOutlet = outlet;\n                }\n                else if (_this._modalNavigationDepth > 0 && outlet.showingModal && !containsLastState) {\n                    // Navigation inside modal view.\n                    _this.upsertModalOutlet(outlet, currentSegmentGroup);\n                }\n                else {\n                    outlet.parent = parentOutlet;\n                    if (_this.updateStates(outlet, currentSegmentGroup)) {\n                        _this.currentOutlet = outlet; // If states updated\n                    }\n                }\n                queue.push(currentSegmentGroup);\n            });\n            currentTree = queue.shift();\n        }\n    };\n    NSLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {\n        var states = this.currentOutlet && this.currentOutlet.states;\n        if (states && states.length > 0) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"NSLocationStrategy.replaceState changing existing state: \" +\n                    (state + \", title: \" + title + \", url: \" + url + \", queryParams: \" + queryParams));\n            }\n        }\n        else {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"NSLocationStrategy.replaceState pushing new state: \" +\n                    (state + \", title: \" + title + \", url: \" + url + \", queryParams: \" + queryParams));\n            }\n            this.pushStateInternal(state, title, url, queryParams);\n        }\n    };\n    NSLocationStrategy.prototype.forward = function () {\n        throw new Error(\"NSLocationStrategy.forward() - not implemented\");\n    };\n    NSLocationStrategy.prototype.back = function (outlet, frame) {\n        this.currentOutlet = outlet || this.currentOutlet;\n        if (this.currentOutlet.isPageNavigationBack) {\n            var states = this.currentOutlet.states;\n            // We are navigating to the previous page\n            // clear the stack until we get to a page navigation state\n            var state = states.pop();\n            var count = 1;\n            if (frame) {\n                while (state.frame && state.frame !== frame) {\n                    state = states.pop();\n                    count++;\n                }\n            }\n            while (!state.isPageNavigation) {\n                state = states.pop();\n                count++;\n            }\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"NSLocationStrategy.back() while navigating back. States popped: \" + count);\n            }\n            this.callPopState(state, true);\n        }\n        else {\n            var state = this.currentOutlet.peekState();\n            if (state && state.isPageNavigation) {\n                // This was a page navigation - so navigate through frame.\n                if (trace_1.isLogEnabled()) {\n                    trace_1.routerLog(\"NSLocationStrategy.back() while not navigating back but top\" +\n                        \" state is page - will call frame.goBack()\");\n                }\n                if (!outlet) {\n                    var topmostFrame = this.frameService.getFrame();\n                    this.currentOutlet = this.getOutletByFrame(topmostFrame) || this.currentOutlet;\n                }\n                var frameToBack = this.currentOutlet.getFrameToBack();\n                if (frameToBack) {\n                    frameToBack.goBack();\n                }\n            }\n            else {\n                // Nested navigation - just pop the state\n                if (trace_1.isLogEnabled()) {\n                    trace_1.routerLog(\"NSLocationStrategy.back() while not navigating back but top\" +\n                        \" state is not page - just pop\");\n                }\n                this.callPopState(this.currentOutlet.states.pop(), true);\n            }\n        }\n    };\n    NSLocationStrategy.prototype.canGoBack = function (outlet) {\n        outlet = outlet || this.currentOutlet;\n        return outlet.states.length > 1;\n    };\n    NSLocationStrategy.prototype.onPopState = function (fn) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.onPopState\");\n        }\n        this.popStateCallbacks.push(fn);\n    };\n    NSLocationStrategy.prototype.getBaseHref = function () {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.getBaseHref()\");\n        }\n        return \"\";\n    };\n    NSLocationStrategy.prototype.callPopState = function (state, pop, outlet) {\n        if (pop === void 0) { pop = true; }\n        outlet = outlet || this.currentOutlet;\n        var urlSerializer = new router_1.DefaultUrlSerializer();\n        var changedOutlet = this.getSegmentGroupByOutlet(outlet);\n        if (state && changedOutlet) {\n            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, state.segmentGroup);\n        }\n        else if (changedOutlet) {\n            // when closing modal view there are scenarios (e.g. root viewContainerRef) when we need\n            // to clean up the named page router outlet to make sure we will open the modal properly again if needed.\n            this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, null);\n        }\n        var url = urlSerializer.serialize(this.currentUrlTree);\n        var change = { url: url, pop: pop };\n        for (var _i = 0, _a = this.popStateCallbacks; _i < _a.length; _i++) {\n            var fn = _a[_i];\n            fn(change);\n        }\n    };\n    NSLocationStrategy.prototype.toString = function () {\n        var result = [];\n        this.outlets.forEach(function (outlet) {\n            var outletStates = outlet.states;\n            var outletLog = outletStates\n                // tslint:disable-next-line:max-line-length\n                .map(function (v, i) { return outlet.outletKeys + \".\" + i + \".[\" + (v.isPageNavigation ? \"PAGE\" : \"INTERNAL\") + \"].[\" + (outlet.modalNavigationDepth ? \"MODAL\" : \"BASE\") + \"] \\\"\" + v.segmentGroup.toString() + \"\\\"\"; })\n                .reverse();\n            result = result.concat(outletLog);\n        });\n        return result.join(\"\\n\");\n    };\n    // Methods for syncing with page navigation in PageRouterOutlet\n    NSLocationStrategy.prototype._beginBackPageNavigation = function (frame) {\n        var outlet = this.getOutletByFrame(frame);\n        if (!outlet || outlet.isPageNavigationBack) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerError(\"Attempted to call startGoBack while going back.\");\n            }\n            return;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.startGoBack()\");\n        }\n        outlet.isPageNavigationBack = true;\n        this.currentOutlet = outlet;\n    };\n    NSLocationStrategy.prototype._finishBackPageNavigation = function (frame) {\n        var outlet = this.getOutletByFrame(frame);\n        if (!outlet || !outlet.isPageNavigationBack) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerError(\"Attempted to call endGoBack while not going back.\");\n            }\n            return;\n        }\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.finishBackPageNavigation()\");\n        }\n        outlet.isPageNavigationBack = false;\n    };\n    NSLocationStrategy.prototype._beginModalNavigation = function (frame) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy._beginModalNavigation()\");\n        }\n        this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;\n        // It is possible to have frame, but not corresponding Outlet, if\n        // showing modal dialog on app.component.ts ngOnInit() e.g. In that case\n        // the modal is treated as none modal navigation.\n        if (this.currentOutlet) {\n            this.currentOutlet.showingModal = true;\n            this._modalNavigationDepth++;\n        }\n    };\n    NSLocationStrategy.prototype._closeModalNavigation = function () {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.closeModalNavigation()\");\n        }\n        var isShowingModal = this._modalNavigationDepth > 0;\n        if (isShowingModal) {\n            this._modalNavigationDepth--;\n        }\n        // currentOutlet should be the one that corresponds to the topmost frame\n        var topmostOutlet = this.getOutletByFrame(this.frameService.getFrame());\n        var outlet = this.findOutletByModal(this._modalNavigationDepth, isShowingModal) || topmostOutlet;\n        if (outlet) {\n            this.currentOutlet = outlet;\n            this.currentOutlet.showingModal = false;\n            this.callPopState(this.currentOutlet.peekState(), false);\n        }\n    };\n    NSLocationStrategy.prototype._beginPageNavigation = function (frame) {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy._beginPageNavigation()\");\n        }\n        this.currentOutlet = this.getOutletByFrame(frame);\n        var lastState = this.currentOutlet.peekState();\n        if (lastState) {\n            lastState.isPageNavigation = true;\n        }\n        var navOptions = this._currentNavigationOptions || defaultNavOptions;\n        if (navOptions.clearHistory) {\n            if (trace_1.isLogEnabled()) {\n                trace_1.routerLog(\"NSLocationStrategy._beginPageNavigation clearing states history\");\n            }\n            this.currentOutlet.states = [lastState];\n        }\n        this._currentNavigationOptions = undefined;\n        return navOptions;\n    };\n    NSLocationStrategy.prototype._setNavigationOptions = function (options) {\n        this._currentNavigationOptions = {\n            clearHistory: lang_facade_1.isPresent(options.clearHistory) ? options.clearHistory : false,\n            animated: lang_facade_1.isPresent(options.animated) ? options.animated : true,\n            transition: options.transition\n        };\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy._setNavigationOptions(\" +\n                (JSON.stringify(this._currentNavigationOptions) + \")\"));\n        }\n    };\n    NSLocationStrategy.prototype._getOutlets = function () {\n        return this.outlets;\n    };\n    NSLocationStrategy.prototype.updateOutletFrame = function (outlet, frame, isEmptyOutletFrame) {\n        var lastState = outlet.peekState();\n        if (lastState && !lastState.frame && !isEmptyOutletFrame) {\n            lastState.frame = frame;\n        }\n        if (!outlet.containsFrame(frame)) {\n            outlet.frames.push(frame);\n        }\n        this.currentOutlet = outlet;\n    };\n    NSLocationStrategy.prototype.clearOutlet = function (frame) {\n        var _this = this;\n        this.outlets = this.outlets.filter(function (currentOutlet) {\n            var isEqualToCurrent;\n            if (_this.currentOutlet) {\n                isEqualToCurrent = currentOutlet.pathByOutlets === _this.currentOutlet.pathByOutlets;\n            }\n            // Remove outlet from the url tree.\n            if (currentOutlet.containsFrame(frame) && !isEqualToCurrent) {\n                _this.callPopState(null, true, currentOutlet);\n            }\n            // Skip frames filtering since currentOutlet is <router-outlet> when no frames available.\n            if (currentOutlet.frames.length && !currentOutlet.isNSEmptyOutlet) {\n                currentOutlet.frames = currentOutlet.frames.filter(function (currentFrame) { return currentFrame !== frame; });\n                return currentOutlet.frames.length;\n            }\n            return !currentOutlet.containsFrame(frame);\n        });\n    };\n    NSLocationStrategy.prototype.getSegmentGroupFullPath = function (segmentGroup) {\n        var fullPath = \"\";\n        while (segmentGroup) {\n            var url = segmentGroup.toString();\n            if (fullPath) {\n                fullPath = (url ? url + \"/\" : \"\") + fullPath;\n            }\n            else {\n                fullPath = url;\n            }\n            segmentGroup = segmentGroup.parent;\n        }\n        return fullPath;\n    };\n    NSLocationStrategy.prototype.getRouteFullPath = function (currentRoute) {\n        var outletName = currentRoute.outlet;\n        var fullPath;\n        currentRoute = currentRoute.parent;\n        while (currentRoute) {\n            var urls = (currentRoute.url.value || currentRoute.url);\n            var url = urls;\n            if (Array.isArray(urls)) {\n                url = url.join(\"/\");\n            }\n            fullPath = fullPath ? (url ? url + \"/\" : url) + fullPath : url;\n            currentRoute = currentRoute.parent;\n        }\n        return fullPath ? fullPath + \"-\" + outletName : outletName;\n    };\n    NSLocationStrategy.prototype.getPathByOutlets = function (urlSegmentGroup) {\n        if (!urlSegmentGroup) {\n            return \"\";\n        }\n        var pathToOutlet;\n        var lastPath = urlSegmentGroup.outlet || \"primary\";\n        var parent = urlSegmentGroup.parent;\n        while (parent && urlSegmentGroup.root !== parent) {\n            if (parent && parent.outlet !== lastPath) {\n                if (lastPath === \"primary\") {\n                    lastPath = parent.outlet;\n                }\n                else {\n                    lastPath = parent.outlet;\n                    pathToOutlet = lastPath + \"-\" + (pathToOutlet || urlSegmentGroup.outlet);\n                }\n            }\n            parent = parent.parent;\n        }\n        return pathToOutlet || lastPath;\n    };\n    NSLocationStrategy.prototype.findOutlet = function (outletKey, activatedRouteSnapshot) {\n        var _this = this;\n        var outlet = this.outlets.find(function (currentOutlet) {\n            var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;\n            return equalModalDepth && currentOutlet.outletKeys.indexOf(outletKey) > -1;\n        });\n        // No Outlet with the given outletKey could happen when using nested unnamed p-r-o\n        // primary -> primary -> prymary\n        if (!outlet && activatedRouteSnapshot) {\n            var pathByOutlets_1 = this.getPathByOutlets(activatedRouteSnapshot);\n            outlet = this.outlets.find(function (currentOutlet) {\n                var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;\n                return equalModalDepth && currentOutlet.pathByOutlets === pathByOutlets_1;\n            });\n        }\n        return outlet;\n    };\n    NSLocationStrategy.prototype.findOutletByModal = function (modalNavigation, isShowingModal) {\n        return this.outlets.find(function (outlet) {\n            var equalModalDepth = outlet.modalNavigationDepth === modalNavigation;\n            return isShowingModal ? equalModalDepth && outlet.showingModal : equalModalDepth;\n        });\n    };\n    NSLocationStrategy.prototype.getOutletByFrame = function (frame) {\n        var outlet;\n        for (var index = 0; index < this.outlets.length; index++) {\n            var currentOutlet = this.outlets[index];\n            if (currentOutlet.containsFrame(frame)) {\n                outlet = currentOutlet;\n                break;\n            }\n        }\n        return outlet;\n    };\n    NSLocationStrategy.prototype.updateStates = function (outlet, currentSegmentGroup) {\n        var isNewPage = outlet.states.length === 0;\n        var lastState = outlet.states[outlet.states.length - 1];\n        var equalStateUrls = outlet.containsTopState(currentSegmentGroup.toString());\n        var locationState = {\n            segmentGroup: currentSegmentGroup,\n            isRootSegmentGroup: false,\n            isPageNavigation: isNewPage\n        };\n        if (!lastState || !equalStateUrls) {\n            outlet.states.push(locationState);\n            // Update last state segmentGroup of parent Outlet.\n            if (this._modalNavigationDepth === 0 && !outlet.showingModal) {\n                this.updateParentsStates(outlet, currentSegmentGroup.parent);\n            }\n            return true;\n        }\n        return false;\n    };\n    NSLocationStrategy.prototype.updateParentsStates = function (outlet, newSegmentGroup) {\n        var parentOutlet = outlet.parent;\n        // Update parents lastState segmentGroups\n        while (parentOutlet && newSegmentGroup) {\n            var state = parentOutlet.peekState();\n            if (state) {\n                state.segmentGroup = newSegmentGroup;\n                newSegmentGroup = newSegmentGroup.parent;\n                parentOutlet = parentOutlet.parent;\n            }\n        }\n    };\n    // tslint:disable-next-line:max-line-length\n    NSLocationStrategy.prototype.createOutlet = function (outletKey, path, segmentGroup, parent, modalNavigation) {\n        var pathByOutlets = this.getPathByOutlets(segmentGroup);\n        var newOutlet = new Outlet(outletKey, path, pathByOutlets, modalNavigation);\n        var locationState = {\n            segmentGroup: segmentGroup,\n            isRootSegmentGroup: false,\n            isPageNavigation: true // It is a new OutletNode.\n        };\n        newOutlet.states = [locationState];\n        newOutlet.parent = parent;\n        this.outlets.push(newOutlet);\n        // Update last state segmentGroup of parent Outlet.\n        if (this._modalNavigationDepth === 0 && !newOutlet.showingModal) {\n            this.updateParentsStates(newOutlet, segmentGroup.parent);\n        }\n        return newOutlet;\n    };\n    NSLocationStrategy.prototype.getSegmentGroupByOutlet = function (outlet) {\n        var pathList = outlet.pathByOutlets.split(\"-\");\n        var segmentGroup = this.currentUrlTree.root;\n        var pathToOutlet;\n        for (var index = 0; index < pathList.length; index++) {\n            var currentPath = pathList[index];\n            var childrenCount = Object.keys(segmentGroup.children).length;\n            if (childrenCount && segmentGroup.children[currentPath]) {\n                var url = segmentGroup.toString();\n                pathToOutlet = pathToOutlet ? pathToOutlet + \"/\" + url : url;\n                segmentGroup = segmentGroup.children[currentPath];\n            }\n            else {\n                // If no child outlet found with the given name - forget about all previously found outlets.\n                // example: seaching for 'primary-second-primary' shouldn't return 'primary-second'\n                // if no 'primary' child available on 'second'.\n                segmentGroup = null;\n                break;\n            }\n        }\n        // Paths should also match since there could be another Outlet\n        // with the same pathByOutlets but different url path.\n        if (segmentGroup && outlet.path && pathToOutlet && outlet.path !== pathToOutlet) {\n            segmentGroup = null;\n        }\n        return segmentGroup;\n    };\n    // Traversal and replacement of segmentGroup.\n    NSLocationStrategy.prototype.updateSegmentGroup = function (rootNode, oldSegmentGroup, newSegmentGroup) {\n        var queue = [];\n        var currentTree = rootNode;\n        while (currentTree) {\n            Object.keys(currentTree.children).forEach(function (outletName) {\n                if (currentTree.children[outletName] === oldSegmentGroup) {\n                    if (newSegmentGroup) {\n                        currentTree.children[outletName] = newSegmentGroup;\n                    }\n                    else {\n                        delete currentTree.children[outletName];\n                    }\n                }\n                queue.push(currentTree.children[outletName]);\n            });\n            currentTree = queue.shift();\n        }\n    };\n    NSLocationStrategy.prototype.upsertModalOutlet = function (parentOutlet, segmentedGroup) {\n        var currentModalOutlet = this.findOutletByModal(this._modalNavigationDepth);\n        // We want to treat every p-r-o as a standalone Outlet.\n        if (!currentModalOutlet) {\n            if (this._modalNavigationDepth > 1) {\n                // The parent of the current Outlet should be the previous opened modal (if any).\n                parentOutlet = this.findOutletByModal(this._modalNavigationDepth - 1);\n            }\n            // No currentModalOutlet available when opening 'primary' p-r-o.\n            var outletName = \"primary\";\n            var outletPath = parentOutlet.peekState().segmentGroup.toString();\n            var outletKey = this.getOutletKey(outletPath, outletName);\n            // tslint:disable-next-line:max-line-length\n            currentModalOutlet = this.createOutlet(outletKey, outletPath, segmentedGroup, parentOutlet, this._modalNavigationDepth);\n            this.currentOutlet = currentModalOutlet;\n        }\n        else if (this.updateStates(currentModalOutlet, segmentedGroup)) {\n            this.currentOutlet = currentModalOutlet; // If states updated\n        }\n    };\n    NSLocationStrategy.prototype.getOutletKey = function (path, outletName) {\n        return path ? path + \"-\" + outletName : outletName;\n    };\n    NSLocationStrategy.prototype.ngOnDestroy = function () {\n        if (trace_1.isLogEnabled()) {\n            trace_1.routerLog(\"NSLocationStrategy.ngOnDestroy()\");\n        }\n        this.outlets = [];\n        this.currentOutlet = null;\n    };\n    NSLocationStrategy = __decorate([\n        core_1.Injectable(),\n        __metadata(\"design:paramtypes\", [platform_providers_1.FrameService])\n    ], NSLocationStrategy);\n    return NSLocationStrategy;\n}(common_1.LocationStrategy));\nexports.NSLocationStrategy = NSLocationStrategy;\n"]}